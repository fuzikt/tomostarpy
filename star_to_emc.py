#!/usr/bin/env python3
import os
import sys
import subprocess
from math import *
from lib.metadata import MetaData
import numpy as np
import argparse
from argparse import RawTextHelpFormatter


class starToEmc:
    def define_parser(self):
        self.parser = argparse.ArgumentParser(
            description="Performs conversion from Relion star file to emClarity template matching csv file. It also generates *.recon.coords files for tomogram subareas.",
            formatter_class=RawTextHelpFormatter)
        add = self.parser.add_argument
        add('--i', help="Input particle star file.")
        add('--o', help="Output prefix. Prefix of the files generated by the script.")
        add('--itomo', type=str, default="",
            help="Input tomogram star file.")
        add('--splitX', type=str, default="2",
            help="Number of subareas to split the tomograms on X axis. Default: 2")
        add('--splitY', type=str, default="2",
            help="Number of subareas to split the tomograms on X axis. Default: 2")
        add('--bin', type=str, default="1",
            help="Binnig factor used for the output mod files. Default: 1")

    def usage(self):
        self.parser.print_help()

    def error(self, *msgs):
        self.usage()
        print("Error: " + '\n'.join(msgs))
        print(" ")
        sys.exit(2)

    def validate(self, args):
        if len(sys.argv) == 1:
            self.error("No input file given.")

        if not os.path.exists(args.i):
            self.error("Input file '%s' not found."
                       % args.i)

    def matrix_from_euler(self, rot, tilt, psi):
        """create a rotation matrix from three Euler anges in ZYZ convention"""
        m = np.zeros((3, 3))

        m[0, 0] = cos(psi) * cos(tilt) * cos(rot) - sin(psi) * sin(rot)
        m[0, 1] = cos(psi) * cos(tilt) * sin(rot) + sin(psi) * cos(rot)
        m[0, 2] = -cos(psi) * sin(tilt)
        m[1, 0] = -sin(psi) * cos(tilt) * cos(rot) - cos(psi) * sin(rot)
        m[1, 1] = -sin(psi) * cos(tilt) * sin(rot) + cos(psi) * cos(rot)
        m[1, 2] = sin(psi) * sin(tilt)
        m[2, 0] = sin(tilt) * cos(rot)
        m[2, 1] = sin(tilt) * sin(rot)
        m[2, 2] = cos(tilt)
        return m

    def writeEmcCSV(self, outputPreffix, binning, tomoSubregion, exportParticles):
        outputEmClarityCSV = outputPreffix + "/convmap/" + tomoSubregion + "_bin" + str(binning) + ".csv"
        with open(outputEmClarityCSV, 'w') as file:
            particleID = 1
            for particle in exportParticles:
                m = self.matrix_from_euler(radians(particle[3]), radians(particle[4]), radians(particle[5]))
                file.write(
                    "1 %s 0 %s 1 1 1 1 1 0 %0.6f %0.6f %0.6f 0 0 0 %0.6f %0.6f %0.6f %0.6f %0.6f %0.6f %0.6f %0.6f %0.6f 1" % (
                    binning, particleID, particle[0], particle[1], particle[2], m[0, 0], m[1, 0], m[2, 0], m[0, 1],
                    m[1, 1], m[2, 1], m[0, 2], m[1, 2], m[2, 2]))
                file.write('\n')
                particleID += 1

        outputEmClarityPos = outputPreffix + "/convmap/" + tomoSubregion + "_bin" + str(binning) + ".pos"
        with open(outputEmClarityPos, 'w') as file:
            for particle in exportParticles:
                file.write("%0.6f %0.6f %0.6f" % (particle[0] / binning, particle[1] / binning, particle[2] / binning))
                file.write('\n')

        outputEmClarityMod = outputPreffix + "/convmap/" + tomoSubregion + "_bin" + str(binning) + ".mod"
        sys.stdout.flush()
        command = "point2model -sphere 3 -scat -inp %s -ou %s > /dev/null" % (
            outputEmClarityPos, outputEmClarityMod)
        proc = subprocess.Popen(command, shell=True)
        proc.wait()

    def writeEmcCoords(self, outputPreffix, tomoname, tomoRegionCoords):
        outputEmClarityCoords = outputPreffix + "/recon/" + tomoname + "_recon.coords"
        with open(outputEmClarityCoords, 'w') as file:
            file.write(tomoname + "\n")
            file.write(str(len(tomoRegionCoords)) + "\n")
            for subregion in tomoRegionCoords:
                file.write("%s\n%s\n%s\n%s\n%s\n%s\n" % (
                subregion[0], subregion[1], subregion[2], subregion[3], subregion[4], subregion[5]))

    def main(self):
        self.define_parser()
        args = self.parser.parse_args()
        self.validate(args)

        xsplit = int(args.splitX)
        ysplit = int(args.splitY)

        outputPreffix = args.o

        binning = int(args.bin)

        # if output dirs do not exist create them
        if not os.path.exists(args.o):
            os.makedirs(args.o)
        if not os.path.exists(args.o + "/recon"):
            os.makedirs(args.o + "/recon")
        if not os.path.exists(args.o + "/convmap"):
            os.makedirs(args.o + "/convmap")

        # read in tomograms
        print("Reading in input star files.....")
        mdtomo = MetaData(args.itomo)
        mdparticles = MetaData(args.i)

        tomograms = []

        for tomogram in mdtomo.data_global:
            tomograms.append(tomogram)

        particles = []

        for particle in mdparticles.data_particles:
            particles.append(particle)

        for tomogram in tomograms:
            tomoSubAreaNr = 0
            tomoRegionCoords = []
            for xsubarea in range(xsplit):
                for ysubarea in range(ysplit):
                    tomoSubAreaNr += 1
                    exportParticles = []
                    xmin = int((tomogram.rlnTomoSizeX / xsplit) * xsubarea)
                    xmax = int(xmin + (tomogram.rlnTomoSizeX / xsplit) - 3)
                    ymin = int((tomogram.rlnTomoSizeY / ysplit) * ysubarea)
                    ymax = int(ymin + (
                                tomogram.rlnTomoSizeY / ysplit) - 3)  # -3 because for some strange reason emClarity has max Y value less than relion
                    origWIDTH = tomogram.rlnTomoSizeX
                    origSLICE1 = 0
                    origSLICE2 = tomogram.rlnTomoSizeY
                    origTHICKNESS = tomogram.rlnTomoSizeZ
                    origSHIFT1 = 0
                    origSHIFT2 = 0.0

                    newWIDTH = xmax - xmin
                    newSLICE1 = ymin
                    newSLICE2 = ymax
                    newTHICKNESS = tomogram.rlnTomoSizeZ
                    newSHIFT1 = tomogram.rlnTomoSizeX / 2 - xmin - newWIDTH / 2
                    newSHIFT2 = 0.0
                    tomoRegionCoords.append([newWIDTH, newSLICE1, newSLICE2, newTHICKNESS, newSHIFT1, newSHIFT2])

                    for particle in particles:
                        if (particle.rlnTomoName == tomogram.rlnTomoName) and (
                                xmin <= particle.rlnCoordinateX <= xmax) and (
                                ymin <= particle.rlnCoordinateY <= ymax) and (
                                0 <= particle.rlnCoordinateZ <= newTHICKNESS):
                            offset_x = ((newWIDTH - origWIDTH) / 2 - origSHIFT1 + newSHIFT1)
                            offset_y = origSLICE1 - newSLICE1
                            offset_z = ((newTHICKNESS - origTHICKNESS) / 2 + origSHIFT2 - newSHIFT2)
                            newXcoord = particle.rlnCoordinateX + offset_x
                            newYcoord = particle.rlnCoordinateY + offset_y
                            newZcoord = particle.rlnCoordinateZ + offset_z
                            exportParticles.append(
                                [newXcoord, newYcoord, newZcoord, particle.rlnAngleRot, particle.rlnAngleTilt,
                                 particle.rlnAnglePsi])
                    tomoSubregion = tomogram.rlnTomoName + "_" + str(tomoSubAreaNr)
                    self.writeEmcCSV(outputPreffix, binning, tomoSubregion, exportParticles)

            self.writeEmcCoords(outputPreffix, tomogram.rlnTomoName, tomoRegionCoords)

        print("All done. Have fun!")


if __name__ == "__main__":
    starToEmc().main()
